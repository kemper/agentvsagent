{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Hearts_Client(enter_arena,get_game_info,get_hand,pass_cards,get_trick,play_card,get_round_result,get_game_result) where
import Data.IORef
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


import Hearts_Types
import Hearts
seqid = newIORef 0
enter_arena (ip,op) arg_request = do
  send_enter_arena op arg_request
  recv_enter_arena ip
send_enter_arena op arg_request = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("enter_arena", M_CALL, seqn)
  write_Enter_arena_args op (Enter_arena_args{f_Enter_arena_args_request=Just arg_request})
  writeMessageEnd op
  tFlush (getTransport op)
recv_enter_arena ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Enter_arena_result ip
  readMessageEnd ip
  case f_Enter_arena_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "enter_arena failed: unknown result")
get_game_info (ip,op) arg_ticket = do
  send_get_game_info op arg_ticket
  recv_get_game_info ip
send_get_game_info op arg_ticket = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("get_game_info", M_CALL, seqn)
  write_Get_game_info_args op (Get_game_info_args{f_Get_game_info_args_ticket=Just arg_ticket})
  writeMessageEnd op
  tFlush (getTransport op)
recv_get_game_info ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Get_game_info_result ip
  readMessageEnd ip
  case f_Get_game_info_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "get_game_info failed: unknown result")
get_hand (ip,op) arg_ticket = do
  send_get_hand op arg_ticket
  recv_get_hand ip
send_get_hand op arg_ticket = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("get_hand", M_CALL, seqn)
  write_Get_hand_args op (Get_hand_args{f_Get_hand_args_ticket=Just arg_ticket})
  writeMessageEnd op
  tFlush (getTransport op)
recv_get_hand ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Get_hand_result ip
  readMessageEnd ip
  case f_Get_hand_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "get_hand failed: unknown result")
pass_cards (ip,op) arg_ticket arg_cards = do
  send_pass_cards op arg_ticket arg_cards
  recv_pass_cards ip
send_pass_cards op arg_ticket arg_cards = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("pass_cards", M_CALL, seqn)
  write_Pass_cards_args op (Pass_cards_args{f_Pass_cards_args_ticket=Just arg_ticket,f_Pass_cards_args_cards=Just arg_cards})
  writeMessageEnd op
  tFlush (getTransport op)
recv_pass_cards ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Pass_cards_result ip
  readMessageEnd ip
  case f_Pass_cards_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "pass_cards failed: unknown result")
get_trick (ip,op) arg_ticket = do
  send_get_trick op arg_ticket
  recv_get_trick ip
send_get_trick op arg_ticket = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("get_trick", M_CALL, seqn)
  write_Get_trick_args op (Get_trick_args{f_Get_trick_args_ticket=Just arg_ticket})
  writeMessageEnd op
  tFlush (getTransport op)
recv_get_trick ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Get_trick_result ip
  readMessageEnd ip
  case f_Get_trick_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "get_trick failed: unknown result")
play_card (ip,op) arg_ticket arg_card = do
  send_play_card op arg_ticket arg_card
  recv_play_card ip
send_play_card op arg_ticket arg_card = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("play_card", M_CALL, seqn)
  write_Play_card_args op (Play_card_args{f_Play_card_args_ticket=Just arg_ticket,f_Play_card_args_card=Just arg_card})
  writeMessageEnd op
  tFlush (getTransport op)
recv_play_card ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Play_card_result ip
  readMessageEnd ip
  case f_Play_card_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "play_card failed: unknown result")
get_round_result (ip,op) arg_ticket = do
  send_get_round_result op arg_ticket
  recv_get_round_result ip
send_get_round_result op arg_ticket = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("get_round_result", M_CALL, seqn)
  write_Get_round_result_args op (Get_round_result_args{f_Get_round_result_args_ticket=Just arg_ticket})
  writeMessageEnd op
  tFlush (getTransport op)
recv_get_round_result ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Get_round_result_result ip
  readMessageEnd ip
  case f_Get_round_result_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "get_round_result failed: unknown result")
get_game_result (ip,op) arg_ticket = do
  send_get_game_result op arg_ticket
  recv_get_game_result ip
send_get_game_result op arg_ticket = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("get_game_result", M_CALL, seqn)
  write_Get_game_result_args op (Get_game_result_args{f_Get_game_result_args_ticket=Just arg_ticket})
  writeMessageEnd op
  tFlush (getTransport op)
recv_get_game_result ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Get_game_result_result ip
  readMessageEnd ip
  case f_Get_game_result_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "get_game_result failed: unknown result")
