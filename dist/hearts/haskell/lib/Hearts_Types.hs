{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Hearts_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


data Suit = CLUBS|DIAMONDS|SPADES|HEARTS  deriving (Show,Eq, Typeable, Ord)
instance Enum Suit where
  fromEnum t = case t of
    CLUBS -> 21
    DIAMONDS -> 22
    SPADES -> 23
    HEARTS -> 24
  toEnum t = case t of
    21 -> CLUBS
    22 -> DIAMONDS
    23 -> SPADES
    24 -> HEARTS
    _ -> throw ThriftException
instance Hashable Suit where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data Rank = TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|JACK|QUEEN|KING|ACE  deriving (Show,Eq, Typeable, Ord)
instance Enum Rank where
  fromEnum t = case t of
    TWO -> 2
    THREE -> 3
    FOUR -> 4
    FIVE -> 5
    SIX -> 6
    SEVEN -> 7
    EIGHT -> 8
    NINE -> 9
    TEN -> 10
    JACK -> 11
    QUEEN -> 12
    KING -> 13
    ACE -> 14
  toEnum t = case t of
    2 -> TWO
    3 -> THREE
    4 -> FOUR
    5 -> FIVE
    6 -> SIX
    7 -> SEVEN
    8 -> EIGHT
    9 -> NINE
    10 -> TEN
    11 -> JACK
    12 -> QUEEN
    13 -> KING
    14 -> ACE
    _ -> throw ThriftException
instance Hashable Rank where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data Position = NORTH|EAST|SOUTH|WEST  deriving (Show,Eq, Typeable, Ord)
instance Enum Position where
  fromEnum t = case t of
    NORTH -> 1
    EAST -> 2
    SOUTH -> 3
    WEST -> 4
  toEnum t = case t of
    1 -> NORTH
    2 -> EAST
    3 -> SOUTH
    4 -> WEST
    _ -> throw ThriftException
instance Hashable Position where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data GameStatus = NEXT_ROUND|END_GAME  deriving (Show,Eq, Typeable, Ord)
instance Enum GameStatus where
  fromEnum t = case t of
    NEXT_ROUND -> 1
    END_GAME -> 2
  toEnum t = case t of
    1 -> NEXT_ROUND
    2 -> END_GAME
    _ -> throw ThriftException
instance Hashable GameStatus where
  hashWithSalt salt = hashWithSalt salt . fromEnum
type Score = Int32

data Card = Card{f_Card_suit :: Maybe Suit,f_Card_rank :: Maybe Rank} deriving (Show,Eq,Typeable)
instance Hashable Card where
  hashWithSalt salt record = salt   `hashWithSalt` f_Card_suit record   `hashWithSalt` f_Card_rank record  
write_Card oprot record = do
  writeStructBegin oprot "Card"
  case f_Card_suit record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("suit",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Card_rank record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rank",T_I32,2)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Card_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Card_fields iprot record{f_Card_suit=Just s}
        else do
          skip iprot _t3
          read_Card_fields iprot record
      2 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Card_fields iprot record{f_Card_rank=Just s}
        else do
          skip iprot _t3
          read_Card_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Card_fields iprot record
read_Card iprot = do
  _ <- readStructBegin iprot
  record <- read_Card_fields iprot (Card{f_Card_suit=Nothing,f_Card_rank=Nothing})
  readStructEnd iprot
  return record
data Ticket = Ticket{f_Ticket_gameId :: Maybe Text,f_Ticket_agentId :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable Ticket where
  hashWithSalt salt record = salt   `hashWithSalt` f_Ticket_gameId record   `hashWithSalt` f_Ticket_agentId record  
write_Ticket oprot record = do
  writeStructBegin oprot "Ticket"
  case f_Ticket_gameId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("gameId",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Ticket_agentId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("agentId",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Ticket_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      1 -> if _t8 == T_STRING then do
        s <- readString iprot
        read_Ticket_fields iprot record{f_Ticket_gameId=Just s}
        else do
          skip iprot _t8
          read_Ticket_fields iprot record
      2 -> if _t8 == T_STRING then do
        s <- readString iprot
        read_Ticket_fields iprot record{f_Ticket_agentId=Just s}
        else do
          skip iprot _t8
          read_Ticket_fields iprot record
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Ticket_fields iprot record
read_Ticket iprot = do
  _ <- readStructBegin iprot
  record <- read_Ticket_fields iprot (Ticket{f_Ticket_gameId=Nothing,f_Ticket_agentId=Nothing})
  readStructEnd iprot
  return record
data EntryRequest = EntryRequest{f_EntryRequest_version :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable EntryRequest where
  hashWithSalt salt record = salt   `hashWithSalt` f_EntryRequest_version record  
write_EntryRequest oprot record = do
  writeStructBegin oprot "EntryRequest"
  case f_EntryRequest_version record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("version",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EntryRequest_fields iprot record = do
  (_,_t13,_id14) <- readFieldBegin iprot
  if _t13 == T_STOP then return record else
    case _id14 of 
      1 -> if _t13 == T_STRING then do
        s <- readString iprot
        read_EntryRequest_fields iprot record{f_EntryRequest_version=Just s}
        else do
          skip iprot _t13
          read_EntryRequest_fields iprot record
      _ -> do
        skip iprot _t13
        readFieldEnd iprot
        read_EntryRequest_fields iprot record
read_EntryRequest iprot = do
  _ <- readStructBegin iprot
  record <- read_EntryRequest_fields iprot (EntryRequest{f_EntryRequest_version=Nothing})
  readStructEnd iprot
  return record
data EntryResponse = EntryResponse{f_EntryResponse_ticket :: Maybe Ticket,f_EntryResponse_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable EntryResponse where
  hashWithSalt salt record = salt   `hashWithSalt` f_EntryResponse_ticket record   `hashWithSalt` f_EntryResponse_message record  
write_EntryResponse oprot record = do
  writeStructBegin oprot "EntryResponse"
  case f_EntryResponse_ticket record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ticket",T_STRUCT,1)
    write_Ticket oprot _v
    writeFieldEnd oprot}
  case f_EntryResponse_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EntryResponse_fields iprot record = do
  (_,_t18,_id19) <- readFieldBegin iprot
  if _t18 == T_STOP then return record else
    case _id19 of 
      1 -> if _t18 == T_STRUCT then do
        s <- (read_Ticket iprot)
        read_EntryResponse_fields iprot record{f_EntryResponse_ticket=Just s}
        else do
          skip iprot _t18
          read_EntryResponse_fields iprot record
      2 -> if _t18 == T_STRING then do
        s <- readString iprot
        read_EntryResponse_fields iprot record{f_EntryResponse_message=Just s}
        else do
          skip iprot _t18
          read_EntryResponse_fields iprot record
      _ -> do
        skip iprot _t18
        readFieldEnd iprot
        read_EntryResponse_fields iprot record
read_EntryResponse iprot = do
  _ <- readStructBegin iprot
  record <- read_EntryResponse_fields iprot (EntryResponse{f_EntryResponse_ticket=Nothing,f_EntryResponse_message=Nothing})
  readStructEnd iprot
  return record
data GameInfo = GameInfo{f_GameInfo_position :: Maybe Position} deriving (Show,Eq,Typeable)
instance Hashable GameInfo where
  hashWithSalt salt record = salt   `hashWithSalt` f_GameInfo_position record  
write_GameInfo oprot record = do
  writeStructBegin oprot "GameInfo"
  case f_GameInfo_position record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("position",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GameInfo_fields iprot record = do
  (_,_t23,_id24) <- readFieldBegin iprot
  if _t23 == T_STOP then return record else
    case _id24 of 
      1 -> if _t23 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_GameInfo_fields iprot record{f_GameInfo_position=Just s}
        else do
          skip iprot _t23
          read_GameInfo_fields iprot record
      _ -> do
        skip iprot _t23
        readFieldEnd iprot
        read_GameInfo_fields iprot record
read_GameInfo iprot = do
  _ <- readStructBegin iprot
  record <- read_GameInfo_fields iprot (GameInfo{f_GameInfo_position=Nothing})
  readStructEnd iprot
  return record
data Trick = Trick{f_Trick_leader :: Maybe Position,f_Trick_played :: Maybe (Vector.Vector Card)} deriving (Show,Eq,Typeable)
instance Hashable Trick where
  hashWithSalt salt record = salt   `hashWithSalt` f_Trick_leader record   `hashWithSalt` f_Trick_played record  
write_Trick oprot record = do
  writeStructBegin oprot "Trick"
  case f_Trick_leader record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("leader",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Trick_played record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("played",T_LIST,2)
    (let f = Vector.mapM_ (\_viter27 -> write_Card oprot _viter27) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Trick_fields iprot record = do
  (_,_t29,_id30) <- readFieldBegin iprot
  if _t29 == T_STOP then return record else
    case _id30 of 
      1 -> if _t29 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Trick_fields iprot record{f_Trick_leader=Just s}
        else do
          skip iprot _t29
          read_Trick_fields iprot record
      2 -> if _t29 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Card iprot)) in do {(_etype34,_size31) <- readListBegin iprot; f _size31})
        read_Trick_fields iprot record{f_Trick_played=Just s}
        else do
          skip iprot _t29
          read_Trick_fields iprot record
      _ -> do
        skip iprot _t29
        readFieldEnd iprot
        read_Trick_fields iprot record
read_Trick iprot = do
  _ <- readStructBegin iprot
  record <- read_Trick_fields iprot (Trick{f_Trick_leader=Nothing,f_Trick_played=Nothing})
  readStructEnd iprot
  return record
data RoundResult = RoundResult{f_RoundResult_north :: Maybe Int32,f_RoundResult_east :: Maybe Int32,f_RoundResult_south :: Maybe Int32,f_RoundResult_west :: Maybe Int32,f_RoundResult_status :: Maybe GameStatus} deriving (Show,Eq,Typeable)
instance Hashable RoundResult where
  hashWithSalt salt record = salt   `hashWithSalt` f_RoundResult_north record   `hashWithSalt` f_RoundResult_east record   `hashWithSalt` f_RoundResult_south record   `hashWithSalt` f_RoundResult_west record   `hashWithSalt` f_RoundResult_status record  
write_RoundResult oprot record = do
  writeStructBegin oprot "RoundResult"
  case f_RoundResult_north record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("north",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RoundResult_east record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("east",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RoundResult_south record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("south",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RoundResult_west record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("west",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RoundResult_status record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("status",T_I32,5)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RoundResult_fields iprot record = do
  (_,_t39,_id40) <- readFieldBegin iprot
  if _t39 == T_STOP then return record else
    case _id40 of 
      1 -> if _t39 == T_I32 then do
        s <- readI32 iprot
        read_RoundResult_fields iprot record{f_RoundResult_north=Just s}
        else do
          skip iprot _t39
          read_RoundResult_fields iprot record
      2 -> if _t39 == T_I32 then do
        s <- readI32 iprot
        read_RoundResult_fields iprot record{f_RoundResult_east=Just s}
        else do
          skip iprot _t39
          read_RoundResult_fields iprot record
      3 -> if _t39 == T_I32 then do
        s <- readI32 iprot
        read_RoundResult_fields iprot record{f_RoundResult_south=Just s}
        else do
          skip iprot _t39
          read_RoundResult_fields iprot record
      4 -> if _t39 == T_I32 then do
        s <- readI32 iprot
        read_RoundResult_fields iprot record{f_RoundResult_west=Just s}
        else do
          skip iprot _t39
          read_RoundResult_fields iprot record
      5 -> if _t39 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_RoundResult_fields iprot record{f_RoundResult_status=Just s}
        else do
          skip iprot _t39
          read_RoundResult_fields iprot record
      _ -> do
        skip iprot _t39
        readFieldEnd iprot
        read_RoundResult_fields iprot record
read_RoundResult iprot = do
  _ <- readStructBegin iprot
  record <- read_RoundResult_fields iprot (RoundResult{f_RoundResult_north=Nothing,f_RoundResult_east=Nothing,f_RoundResult_south=Nothing,f_RoundResult_west=Nothing,f_RoundResult_status=Nothing})
  readStructEnd iprot
  return record
data GameResult = GameResult{f_GameResult_north :: Maybe Int32,f_GameResult_east :: Maybe Int32,f_GameResult_south :: Maybe Int32,f_GameResult_west :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable GameResult where
  hashWithSalt salt record = salt   `hashWithSalt` f_GameResult_north record   `hashWithSalt` f_GameResult_east record   `hashWithSalt` f_GameResult_south record   `hashWithSalt` f_GameResult_west record  
write_GameResult oprot record = do
  writeStructBegin oprot "GameResult"
  case f_GameResult_north record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("north",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_GameResult_east record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("east",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_GameResult_south record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("south",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_GameResult_west record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("west",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GameResult_fields iprot record = do
  (_,_t44,_id45) <- readFieldBegin iprot
  if _t44 == T_STOP then return record else
    case _id45 of 
      1 -> if _t44 == T_I32 then do
        s <- readI32 iprot
        read_GameResult_fields iprot record{f_GameResult_north=Just s}
        else do
          skip iprot _t44
          read_GameResult_fields iprot record
      2 -> if _t44 == T_I32 then do
        s <- readI32 iprot
        read_GameResult_fields iprot record{f_GameResult_east=Just s}
        else do
          skip iprot _t44
          read_GameResult_fields iprot record
      3 -> if _t44 == T_I32 then do
        s <- readI32 iprot
        read_GameResult_fields iprot record{f_GameResult_south=Just s}
        else do
          skip iprot _t44
          read_GameResult_fields iprot record
      4 -> if _t44 == T_I32 then do
        s <- readI32 iprot
        read_GameResult_fields iprot record{f_GameResult_west=Just s}
        else do
          skip iprot _t44
          read_GameResult_fields iprot record
      _ -> do
        skip iprot _t44
        readFieldEnd iprot
        read_GameResult_fields iprot record
read_GameResult iprot = do
  _ <- readStructBegin iprot
  record <- read_GameResult_fields iprot (GameResult{f_GameResult_north=Nothing,f_GameResult_east=Nothing,f_GameResult_south=Nothing,f_GameResult_west=Nothing})
  readStructEnd iprot
  return record
